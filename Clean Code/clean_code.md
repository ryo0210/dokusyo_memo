# Clean Code

![Book Cover](https://github.com/ryo0210/dokusyo_memo/blob/main/Clean%20Code/book_cover.jpg)

### 第2章 意味のある名前

- 意図が明確な名前にする
- 偽情報を避ける
- 意味のある対比を行う
- 発音可能な名前を使用する
- 検索可能な名前を用いる
- エンコーディングを避ける
- ハンガリアン記法
- メンバープレフィクス
- インターフェイスと実装
- メンタルマッピングを避けるクラス名
- メソッド名
- 気取らない
- 1つのコンセプトには1つの単語
- ごろ合わせをしない
- 解決領域の用語の使用
- 問題領域の用語の使用
- 意味のある文脈を加える
- 根拠のない文脈を与えない

### 第3章 関数

- 小さいこと！
    - 関数の長さは本文で4行程度が理想
- 1つのことを行う
    - 関数を書く目的は、一つの広い概念を次の抽象レベルのいくつかのステップに分解すること
- 1つの関数に1つの抽象レベル
    - 逓減規則：関数の抽象レベルが降順になるようにする
    - 関数がTO節のように読める必要がある
        - 節にはその場所での抽象レベルについての記述と、続く次のレベルのTO節への参照を含む
            - {関数名}するためには{関数内の処理}を行う（TO {関数名}, {関数内の処理}）
            - To include the setups and teardowns（開始と終了内容を取り込むためには)、 まず開始内容を取り込み､テストページの内容を取り込み､そして終了内容を取り込む）
            - To include the setups（開始内容を取り込むためには)、 もし、それがテストスイートならば、テストスイートを取り込み、そして通常の開始内容を取り込む）
            - To include the suite setup（テストスイートを取り込むためには、親階層の 「SuiteSetup｣ ページ を探し、このページのパスを持った include文を加える）
            - To search the parent（親階層の中を検索するには...）
- switch文
    - switch文を使う場合、switch文を抽象レベルの最下層である抽象ファクトリに置き、人目に触れないようにする
- 内容をよく表す名前を使う
    - 内容をよく表す長い名前は、不可解な短い名前や、内容を説明した長いコメントより優れている
- 関数の引数
    - 理想の関数の引数は0で、3つ以上は作らない
    - 共通モナディック形式
        - 一般的な1引数の関数の挙動は以下の通りで、これらとは違う挙動をする1引数の関数は作成しないようにする。また、それぞれの違いが明確にわかるような名前を付ける
            - 引数で渡したものについて照会を行う
            - 引数に対してある操作し、変換して返す
            - イベント発生としてで、システムの状態を変更する。戻り値はない
    - フラグ引数
        - フラグ引数の関数はtrueの時とfalseの時で2つ以上の事をしようとしているので良くない
    - 引数リスト
        - 関数にわたい引数の数が変わる場合（可変引数）、その全てが同じように扱われるのであれば、List型で指定された1つの引数と等価であると見なせる
    - 動詞とキーワード
        - 関数名がキーワード形式になっており、引数名を関数名にエンコードすると分かりやすくなる
- 副作用を避ける
- コマンド・照会の分離原則
    - 関数は、何らかの処理を行うか、何らかの応答を返すかのどちらかを行うべき
- 戻りコードよりも例外を好む
    - エラーコードを返すと、呼び出し元がすぐにエラー処理をしなければならない（コマンド・照会の分離原則も違反している）
    - 例外を使用すればエラー処理のコードは、本来の処理から分離されコードが単純になる
    - try/catch ブロックの分離
        - try/catch ブロックはそれ自体が複雑なので、tryブロック、 catchブロックのそれぞれの中の処理を単一の関数にする
- DRY（Don’t Repeat Yourself）原則
    - 重複するコードを書くな
- 構造化プログラミング
- なぜ関数をこのように書くのでしょう？
- 結論

### 第4章 コメント

- コメント
    - コメントとは常に失敗である
        - コメントは、コードで上手く処理を表現するうことに失敗した時に、それを補うために使う
    - コードを嫌う理由。以下の理由から、必要な場面以外はコメントを最小限にするために多大な努力をするべきである
        - コードは変更され、移動され、進化していき、コメントは置き去りにされ、次第に正確さを失っていくから
        - コメントのメンテナンスに労力を使うくらいなら、まず、コードを明確にし、表現豊かにすることで、そもそもコメントを書かなくても良い状態にするべき
        - 不正確なコメントは、人を惑わせ誤解に導く
        - コードこそが真実を表しており、あなたの処理を真に語っている
- コメントで、ダメなコードを取り繕うことはできない
    - 分かりにくいコードに対して、コメントを入れて改善しようと思ってはいけない
- 自分自身をコードの中で説明する
    - 大抵の場合、コメントに書きたかった内容の処理を実行する関数を作成するだけ
- よいコメント
    - まっとうなコメント
        - ライセンスや著作権などの必要なコメント。ただし、可能であれば条件などをコメントに書くのではなく、そこへの参照を記載するに止める
    - 情報を与えるコメント
    - 意図の説明
        - •「何故そうしたのか？」のような裏にある意図の説明はコードで表現することができないので、補足としてコメントするのは有益。
    - 明確化
        - 曖昧な引数、戻り値の意味を明確化するためにコメントすることは有益である
        - しかし、同時にそのコメントが正しいかどうかの確認作業が増えるためやっかい（他に方法がないかを検討し、ない場合はコメントを間違えないように十分に注意する必要がある）
    - 結果に対する警告
        - 例えば、あるメソッドが実行に時間がかかる場合やスレッドセーフ（そのコードを複数のスレッドが同時並行的に実行しても問題が発生しないこと）でない場合など
        - （現在では、実行に時間がかかり、テストケースをオフにする場合は、@Ignore(”Take  too long to run”)のようにコードで表現できる）
    - TODO コメント
    - 強調
        - 一見、理解不能な実装についてのコメント
    - 公開 API における Javadoc

- よくないコメント
    - ぶつぶついう
        - 他のモジュールを調べないと意味がわからないようなコメントは、情報伝達に失敗しており、価値がない
    - 冗長なコメント
    - 誤解を招くコメント
    - 命令コメント
        - 全ての変数や関数にコメントの記述を強制するのは、ただ単にコード分かりにくくし、潜在的な嘘と間違いを生産することになる
    - 日誌コメント
    - ノイズコメント
        - 意味のないコメントは、次第に無視されるようになり、コード変更のタイミングで嘘のコメントになってしまう可能性がある
    - 恐るべきノイズ
    - 関数や変数が使用できるのであれば、コメントを使用しないこと
    - 道標
    - 閉じカッココメント
        - 長文のif文やtry/catchの閉じ括弧部分にif文の条件式やtry文, catch文であることを示すようなコメントを書くなら、関数を短くする
    - 属性と署名
    - コメントアウトされたコード
    - HTML コメント
    - 非局所的な情報
    - 多すぎる情報
    - 不明確なつながり
        - コメントに対してさらに説明が必要な情けないコメントは書くな
    - 関数ヘッダ
        - 関数に良く練られた名前を付け、小さくし、1つのことのみを行うようにすればコメントは不要だし、コメントヘッダを付けることよりも優れている
    - 非公開コードの Javadoc


### 第5章 書式化

- 縦方向の書式化
    - 新聞にたとえる
    - 垂直概念分離性
    - 垂直密度
    - 垂直距離
    - 垂直方向の並び順
- 横方向の書式化
    - 水平分離性と密度
    - 水平方向の位置合わせ
    - インデント
    - ダミーのスコープ
- チームの規則

### 第6章 オブジェクトとデータ構造

- オブジェクトとデータ構造
    - privateの変数に対してゲッターとセッターを用意することは、publicにしているようなもの
- データ抽象化
    - 実装の隠蔽とは抽象化
    - クラスはインターフェイスを使うことでデータの実装を見せずに、利用者に対しデータの本質を操作することを可能にする
- データ／オブジェクトの非対称性
    - データ
        - データ構造は、データを公開し、機能は何も提供しない
        - 新たな関数を、既存のデータ構造に影響を与えずに追加できるが、
        新たなデータ構造を追加するには、既存の全ての関数を変えなければならない
    - オブジェクト
        - オブジェクトは、裏にあるデータを隠して抽象化し、データの操作する機能を公開する
        - 新たなクラスを、既存の関数を変えることなく追加できるが、
        新たな関数を追加するには、全てのクラスを変えなければならない
- デメテルの法則
    - 電車の衝突
    - 混血児
        - private変数を実質publicのように公開されたデータ構造と、重要な処理を行う関数を持った混血児クラスを作ってはいけない
- データ転送オブジェクト
    - アクティブレコード


### 第7章 エラー処理

- エラー処理
    - エラー処理は重要だが、本来のロジックが不明瞭にならないようにする必要がある
- リターンコードではなく、例外を使用する
    - エラー処理は、例外を投げてtry/catch文で処理する方が、本来のロジックと2つに関心事を分けることができ、明瞭なコードになる
- 最初にtry-catch-finally文を書く
    - tryブロックはトランザクションのように捉えることができ、最初にtry-catch-finally文を書くと、スコープを意識したコードが書ける
- 非チェック例外を使用する
- 例外で状況を伝える
    - 例外は、エラー場所や原因を判断できる十分な情報を伝える必要がある
- 呼び出し元が必要とする例外クラスを定義する
    - 多くの種類の例外を設定していて、エラー処理の内容が例外の種類によって変わらないのであれば、ラップして共通の例外を投げるようにする
    - こうすることによって以下のメリットがある
        - アプリケーションを特定のベンダのAPIの設計に依存させなくて済む
        - 別のライブラリへの乗り換えが容易になる
        - テストを行う際に、サードパーティライブラリのモック作成が容易になる
    - 例外の情報によってエラーの判別は可能なので、多くの場合、特定の領域のコードでは、1つの例外クラスを使用することが適している
    - 別の例外はキャッチしたくないという場合に限って別のクラスを使用するようにする
- 正常ケースのフローを定義する
    - 例外処理によって、本来の処理が分断されるのは良くない
    - スペシャルケース（null object）パターンを利用して、例外処理を必要としない設計にする
- nullを返さない
    - nullを返したい時は、例外を投げるかスペシャルケース（null object）パターンを検討して、nullチェック文を無くす
    - サードパーティのAPIに関しても、nullを返すのであればそのメソッドをラップして上記の方法を検討する
- nullを渡さない
    - 多くのプログラミング言語ではnullが渡され場合、上手く対処する方法がない（例外を投げるよりアサーションを使うことで文章化できるが、根本的な問題を解決するわけではない）
    - nullを渡すことを禁止とし、nullが入ってきた場合は何らかの間違いとする
- 結論
    - クリーンコードは読みやすいだけではなく、堅牢でなくてはならない

### 第8章 境界

- サードパーティーのコードを使用する
    - インターフェイス境界をシステム内で持ち回るべきではない
    - クラスの中だけ、あるいは、強い関連をもたクラスに止める
- 境界の調査と学習
    - サードパーティーのコードの使い方を学ぶときに、そのコードのテストを書いて学習する「学習テスト」という方法がある
- log4jを学習する
- 学習テストは、タダ以上のものである
- まだ存在しないコードを使用する
    - APIの設計がまだされていない場合、Adapterパターンを使う
    - AdapterパターンはAPIとのやりとりをカプセル化し、変更箇所を1箇所に局所化できる
- きれいな境界
    - 自分達が制御できないもの（サードパーティーコード）ではなく、制御できるものに対して依存するようにする
    - サードパーティーとの境界を管理するためん、コードの中に非常に小さな領域を設け、そこからサードパーティーのコードの問い合わせを行うようにする

### 第9章 単体テスト

- TDD三原則
    - 第一則：失敗する単体テストのコードを書く前に製品コードを書いてはならない
    - 第二則：コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない
    - 第三則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない。
- テストをきれいに保つ
    - テストはxxx性を可能とする
        - 単体テストはコードの柔軟性、保守容易性、再利用性を維持、提供してくれるもの
        - テストがあれば変更を恐れずに行うことができる
        - テストが汚いとコードも汚くなっていき、テストを失うことになる。最終的にはコードが腐る
- クリーンテスト
    - テストに関係のない部分で、実装の詳細コードがずらずらと書いてあると、ノイズでしかない
    - テストコードは「構築」「操作」「検査」のブロックに分かれていると理解しやすい
    - ドメイン特化テスト言語
        - テストを簡単に読み書きできる、テストに特化した関数とユーティリティのAPIをテスト言語（ドメイン特化言語（DSL））と呼ぶ
    - 二重規範
- 1つのテストに1つのアサート
    - 関数名は対象-条件-想定結果集約に従わせる
        - 1つのテストに1つのアサートを行おうとすると、重複したコードが出てしまう
        - テンプレートメソッドパターンを使って**対象/条件部分**をベースクラスに入れ、想定結果部分を継承クラス側に入れることで解決できる。あるいは、これらを全く別のテストクラスに入れて、**対象/条件部分**を@Before関数に入れて想定結果部分をそれぞれの@Test関数に入れても良い
        - しかし、これらの対応は大袈裟すぎる（厳しすぎる）ので、なるべく少なくなるようにすれば、著者は2つ以上のアサート文を入れてもかまわない方針
        - 複数のアサートがあったとしても、1つのテストでは1つの概念を扱う
- F.I.R.S.T.
    - Fast（高速である）
        - テスト実行に時間がかかると、テストへの心理的ハードルが高くなり、コードが腐り始める
    - Independent（独立している）
        - 全てのテストは独立していて、前提条件などなく好きな順序で実行できるようにする。テストが関連していると、テスト後半部分が隠れてしまう
    - Repeatable（再現性がある）
        - 本番環境でも、品質保証環境でも、どんな環境でも再現可能でなければならない。動かない環境があると言う事はテストが失敗する言い訳をいつも抱えているという事を意味する
    - Self-Validating（自己検証可能性）
        - テストの結果は、成功か失敗のどちらかを出力するべき。
    - Timely（適宜性ある）
        - 製品コードを書く直前に単体テストテスト必要がある

### 第10章 クラス

- クラスの構成
    - カプセル化
- クラスは小さくしなければならない！
    - クラス名は裏すの責務を表すべきである
    - クラスの説明に「もし」「そして」「あるいわ」「しかし」といった単語以外を使って説明できるべきである
    - 単一責務の原則
        - クラス、モジュールは変更の原因となるものが1つでなければならない
    - 凝集性
    - 凝集性に気を配ると、大量の小さなクラスが生まれる
- 変更のために最適化する
    - 変更から切り離す
        - 結合を最小化することで、依存関係逆転の原則（クラスは抽象層にのみ依存するべきで、詳細な具体層に依存するべきではない）に沿わせることができる

### 第11章 システム

- あなたは、街をどうやって造りますか？
- システムを使うことと、構築することとを分離する
    - オブジェクトを生成する構築ロジックと、通常の実行処理、依存関係の解決する処理は、分離すべき
    - mainの分離
        - main関数を用意して、そこで全ての依存関係の解決を行う
        - アプリケーション側は、mainや構築側の処理について何ら知らない状態になる            
    - ファクトリ
        - オブジェクトの生成に対してアプリケーションが責任を持たなければならない場合も、ファクトリパターンを使えば生成のタイミングはアプリケーションが制御可能にしつつ、生成に関する詳細をアプリケーションコードから分離できる
    - 依存性注入
        - 依存性注入（DI）は、依存関係の管理をアプリケーションから分離するための強力な仕組みである
        - クラスはセッタメソッド、コンストラクタ引数を通して依存性の注入を受ける
- スケールアップ
    - スケールアップ
        - 関心事がきちんと分離してあれば、システムを拡張していくことができる
    - 横断的関心事
        - 多くのオブジェクトにまたがって同じコードを実装しなければならないような関心事を横断的関心事という
        - アスペクト指向プログラミングは横断的関心事に対してモジュール構造を取り戻すための一般的なアプローチ
- Javaプロキシ
- Pure JavaのAOPフレームワーク
- AspectJアスペクト
- システムアーキテクチャのテスト実行
- 意思決定を最適化する
    - 決定のタイミングは、それが手遅れとなるまで待つことで最善の情報に裏付けられた決断ができる
- 論証可能な価値を追加する際には、標準を賢く使用する
- システムはドメイン特化言語を必要とする
    - ドメイン特化言語は、ドメインの概念とそれを実装するコードの間の「コミュニケーションギャップ」を極小化できる
    - 実装に使う言語をドメイン専門家と同じものを使えば、ドメインから実装への翻訳で間違えるリスクが減少する

### 第12章 創発

- 優れた設計を生み出す4つの単純な規則
    1. 全テストを実行する
        - 包括的なテストが必要であり、それを常に流し続ける必要がある
        - この単純で明確な規則に従うことで、低結合と高凝集に準拠できるかどうかに影響与える
    2. 重複がない
        - 数行であったとしてもコードの重複は排除する
        - そのことでSRP違反や別のメソッドやクラスに抽出するきっかけになったり、再利用化することができる
        - 高いレベルの重複を取り除くことのできるテンプレートメソッドパターンがある
    3. プログラマの意図が表現されている
        - 書き手の意図の表現が明確であれば、理解に必要な時間が減少する
        - これは不具合を減らし保守コストを低減させる
        - 意図を表現するためには
            - 関数やクラスを小さく保つ
            - デザインパターンなど標準の用語を用いる
            - 適切な（使用例が文章化された）単体テストを記述する
    4. クラフトメソッドを最小化する
        - システム全体を小さくしつつ関数とクラスも小さくする
        - ただし、やりすぎないように注意が必要

### 第13章 同時並行性

- なぜ同時並行性が必要なのか？
    - なぜ同時並行性が必要なのか？
        - 同時並行性は、処理を「何を実行するか」と「いつ実行するか」に分離することができる
        - 応答時間とスループットの制約を解決できる
    - 神話と誤解
        - 同時並行はパフォーマンスを改善できる可能性があるが、それは、待ち時間が大量にあり、複数のスレッドやプロセッサで共有できる場合のみ
        - 同時並行アルゴリズムはシングルスレッドとは大きく異なることがある
        - コンテナが何を行い、どのように同時更新とデッドロックの問題に対処しているのかを理解しておくことが望ましい
        - 同時並行性には余分なコード、オーバーヘッドがつきまとう
        - とくべき問題が単純であったとしても、正しい同時並行性の確保は複雑になる
        - 同時並行性のバグには、大抵は再現性がなく、一過性の問題として片付けられてしまうことがよくある
        - 同時並行生の実現のために、設計戦略の根幹を変更しなければならない場合がよくある
- 難問
- 同時並行性防御原則
    - 単一責務の原則
        - 単一責務の原則に違反しないように、同時並行性に関係するコードは本来のコードから分離する
    - 帰結：データのスコープを限定せよ
        - 複数のスレッドでデータを共有すると予期されない挙動を招くので、共有される可能性のあるデータへのアクセスを厳しく制限し、カプセル化を徹底する
    - 帰結：データのコピーを使用せよ
        - データの共有を避けるために、データをコピーしてそれを読み出し専用とみなす方法や、オブジェクトをコピーし、複数のスレッドの結果を集め、1つのスレッドでマージする方法もある
    - 帰結：スレッドはできる限り独立させよ
        - データをお互いに依存しないサブセットに分割することができれば、それらをさらに独立したスレッド、プロセッサで処理することが可能になる
- 使用しているライブラリを知る
    - 提供されているスレッドセーフなコレクションを利用する
    - お互いに関係しないタスクの実行に、 エグゼキュタフレームワークを利用する
    - 可能であれば、 ブロックしない方法を用いる
    - ライブラリのいくつかのクラスはスレッドセーフではない
- コレクション実行モデルを見分ける
    - 同時並行処理における実行モデル
        - プロデューサーコンシューマ
            - プロデューサースレッドが作業を生成してキューに格納し、コンシューマスレッドはキューから作業を取り出して完了させる
            - キューは束縛リソース（同時並行処理環境で使用される固定長のリソース、あるいは数値）になる
        - リーダーライター
            - 共有リソースのライターは多くのリーダーを長時間ロックさせてしまい、スループットの問題を引き起こしがちになる
            - リーダーを優先するとライターが飢餓状態（実行機会を与えられない状態）になる
            - ライターを優先するとスループットが悪化する
            - 正しい動作、許容範囲のスループット、飢餓状態の回避を満たしつつリーダーとライターの要件の妥協点を見つけることが必要
        - 哲学者の食事
            - リソース競合を起こすシステムは、デッドロック（複数のスレッドがお互いのリソースを要求し、お互いの終了を待ち合わせている状態）、ライブロック（複数のスレッドがお互いに邪魔しあい、再試行を繰り返して長時間あるいは永遠に処理がに進まない状態）スループット効率低下といった問題を起こす
- 同期化メソッド間の依存関係に注意
    - 共有されるオブジェクトのメソッドを2つ以上使用しないようにする
- 同期化セクションを小さくする
    - プログラムが正しく動作するように、セクションのコードが実行されないようにするクリティカルセッションはなるべく小さくするべき
- 正確な終了処理コードを書くのは難しい
- スレッド化されたコードのテスト
    - スレッド化されたコードのテスト
        - 潜在的問題をあぶり出すテストを書き、システム設定上で頻繁に実行して確認する
    - 怪しい失敗を、スレッド問題の容疑者として扱う
        - スレッド化されたコードは簡単には起きないエラーを引き起こす
        - これを一過性の問題と無視すれば無視するほど潜在的な欠陥を持ったやり方に立脚することになる
    - 最初にスレッド化されていないコードを完成させる
    - スレッド化されたコードは差し替え可能とする
    - スレッド化されたコードをチューニング可能にしておく
        - 使用するスレッドの数を簡単に調整できるようにして、スループット、システム使用率をもとに自分自身をチューニング可能にしておく
    - プロセッサの数よりスレッドの数を多くする
        - 問題はシステムがタスクスイッチするときに起きるため、プロセッサのコアの数よりも多いスレッドを実行する
        - タスクスイッチが頻繁になればなるほど、クリティカルセクションの不備やデッドロックといった問題を持ったコードが見つかる
    - 異なるプラットフォームで実行する
    - コードに対していろいろなことを試し、強制的にエラーを発生させる
        - 手作業によるもの
            - wait(), sleep(), yield(), priority()などのメソッドを追加することで、多くの異なったタイミングを生成することができる
            - ただし以下のような問題がある
                - この方法を施す場所を手作業で見つけなければならない
                - どこに入れるべきか、何の呼び出しを追加するのかをどうやって判断すれば良いのか？
                - このようなことが本番環境に残ると、コードの実行速度が低下する
                - あまり効果的なやり方ではない
        - 自動的に行うもの
            - アスペクト指向フレームワークを使うことでプログラムでランダムに多くの異なったタイミングを生成することができる
            - 重要なのはコードに異なる順序、異なるタイミングで揺さぶりをかけることである

### 第14章 継続的改良

- Argsの実装
- Argsクラス
- 大雑把な下書き
- 文字列引数

### 第15章 JUnitの内部

- JUnitフレームワーク

### 第16章 SerialDateのリファクタリング

- まずは、動作するようにする
- そして正しく直した

