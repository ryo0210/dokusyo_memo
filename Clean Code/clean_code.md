# Clean Code

![Book Cover](https://github.com/ryo0210/dokusyo_memo/blob/main/Clean%20Code/book_cover.jpg)


### 第3章 関数

- 小さいこと！
    - 関数の長さは本文で4行程度が理想
- 1つのことを行う
    - 関数を書く目的は、一つの広い概念を次の抽象レベルのいくつかのステップに分解すること
- 1つの関数に1つの抽象レベル
    - 逓減規則：関数の抽象レベルが降順になるようにする
    - 関数がTO節のように読める必要がある
        - 節にはその場所での抽象レベルについての記述と、続く次のレベルのTO節への参照を含む
            - {関数名}するためには{関数内の処理}を行う（TO {関数名}, {関数内の処理}）
            - To include the setups and teardowns（開始と終了内容を取り込むためには)、 まず開始内容を取り込み､テストページの内容を取り込み､そして終了内容を取り込む）
            - To include the setups（開始内容を取り込むためには)、 もし、それがテストスイートならば、テストスイートを取り込み、そして通常の開始内容を取り込む）
            - To include the suite setup（テストスイートを取り込むためには、親階層の 「SuiteSetup｣ ページ を探し、このページのパスを持った include文を加える）
            - To search the parent（親階層の中を検索するには...）
- switch文
    - switch文を使う場合、switch文を抽象レベルの最下層である抽象ファクトリに置き、人目に触れないようにする
- 内容をよく表す名前を使う
    - 内容をよく表す長い名前は、不可解な短い名前や、内容を説明した長いコメントより優れている
- 関数の引数
    - 理想の関数の引数は0で、3つ以上は作らない
    - 共通モナディック形式
        - 一般的な1引数の関数の挙動は以下の通りで、これらとは違う挙動をする1引数の関数は作成しないようにする。また、それぞれの違いが明確にわかるような名前を付ける
            - 引数で渡したものについて照会を行う
            - 引数に対してある操作し、変換して返す
            - イベント発生としてで、システムの状態を変更する。戻り値はない
    - フラグ引数
        - フラグ引数の関数はtrueの時とfalseの時で2つ以上の事をしようとしているので良くない
    - 引数リスト
        - 関数にわたい引数の数が変わる場合（可変引数）、その全てが同じように扱われるのであれば、List型で指定された1つの引数と等価であると見なせる
    - 動詞とキーワード
        - 関数名がキーワード形式になっており、引数名を関数名にエンコードすると分かりやすくなる
- 副作用を避ける
- コマンド・照会の分離原則
    - 関数は、何らかの処理を行うか、何らかの応答を返すかのどちらかを行うべき
- 戻りコードよりも例外を好む
    - エラーコードを返すと、呼び出し元がすぐにエラー処理をしなければならない（コマンド・照会の分離原則も違反している）
    - 例外を使用すればエラー処理のコードは、本来の処理から分離されコードが単純になる
    - try/catch ブロックの分離
        - try/catch ブロックはそれ自体が複雑なので、tryブロック、 catchブロックのそれぞれの中の処理を単一の関数にする
- DRY（Don’t Repeat Yourself）原則
    - 重複するコードを書くな
- 構造化プログラミング
- なぜ関数をこのように書くのでしょう？
- 結論

### 第4章 コメント

- コメント
    - コメントとは常に失敗である
        - コメントは、コードで上手く処理を表現するうことに失敗した時に、それを補うために使う
    - コードを嫌う理由。以下の理由から、必要な場面以外はコメントを最小限にするために多大な努力をするべきである
        - コードは変更され、移動され、進化していき、コメントは置き去りにされ、次第に正確さを失っていくから
        - コメントのメンテナンスに労力を使うくらいなら、まず、コードを明確にし、表現豊かにすることで、そもそもコメントを書かなくても良い状態にするべき
        - 不正確なコメントは、人を惑わせ誤解に導く
        - コードこそが真実を表しており、あなたの処理を真に語っている
- コメントで、ダメなコードを取り繕うことはできない
    - 分かりにくいコードに対して、コメントを入れて改善しようと思ってはいけない
- 自分自身をコードの中で説明する
    - 大抵の場合、コメントに書きたかった内容の処理を実行する関数を作成するだけ
- よいコメント
    - まっとうなコメント
        - ライセンスや著作権などの必要なコメント。ただし、可能であれば条件などをコメントに書くのではなく、そこへの参照を記載するに止める
    - 情報を与えるコメント
    - 意図の説明
        - •「何故そうしたのか？」のような裏にある意図の説明はコードで表現することができないので、補足としてコメントするのは有益。
    - 明確化
        - 曖昧な引数、戻り値の意味を明確化するためにコメントすることは有益である
        - しかし、同時にそのコメントが正しいかどうかの確認作業が増えるためやっかい（他に方法がないかを検討し、ない場合はコメントを間違えないように十分に注意する必要がある）
    - 結果に対する警告
        - 例えば、あるメソッドが実行に時間がかかる場合やスレッドセーフ（そのコードを複数のスレッドが同時並行的に実行しても問題が発生しないこと）でない場合など
        - （現在では、実行に時間がかかり、テストケースをオフにする場合は、@Ignore(”Take  too long to run”)のようにコードで表現できる）
    - TODO コメント
    - 強調
        - 一見、理解不能な実装についてのコメント
    - 公開 API における Javadoc

- よくないコメント
    - ぶつぶついう
        - 他のモジュールを調べないと意味がわからないようなコメントは、情報伝達に失敗しており、価値がない
    - 冗長なコメント
    - 誤解を招くコメント
    - 命令コメント
        - 全ての変数や関数にコメントの記述を強制するのは、ただ単にコード分かりにくくし、潜在的な嘘と間違いを生産することになる
    - 日誌コメント
    - ノイズコメント
        - 意味のないコメントは、次第に無視されるようになり、コード変更のタイミングで嘘のコメントになってしまう可能性がある
    - 恐るべきノイズ
    - 関数や変数が使用できるのであれば、コメントを使用しないこと
    - 道標
    - 閉じカッココメント
        - 長文のif文やtry/catchの閉じ括弧部分にif文の条件式やtry文, catch文であることを示すようなコメントを書くなら、関数を短くする
    - 属性と署名
    - コメントアウトされたコード
    - HTML コメント
    - 非局所的な情報
    - 多すぎる情報
    - 不明確なつながり
        - コメントに対してさらに説明が必要な情けないコメントは書くな
    - 関数ヘッダ
        - 関数に良く練られた名前を付け、小さくし、1つのことのみを行うようにすればコメントは不要だし、コメントヘッダを付けることよりも優れている
    - 非公開コードの Javadoc


### 第5章 書式化

- 縦方向の書式化
    - 新聞にたとえる
    - 垂直概念分離性
    - 垂直密度
    - 垂直距離
    - 垂直方向の並び順
- 横方向の書式化
    - 水平分離性と密度
    - 水平方向の位置合わせ
    - インデント
    - ダミーのスコープ
- チームの規則

### 第6章 オブジェクトとデータ構造

- オブジェクトとデータ構造
    - privateの変数に対してゲッターとセッターを用意することは、publicにしているようなもの
- データ抽象化
    - 実装の隠蔽とは抽象化
    - クラスはインターフェイスを使うことでデータの実装を見せずに、利用者に対しデータの本質を操作することを可能にする
- データ／オブジェクトの非対称性
    - データ
        - データ構造は、データを公開し、機能は何も提供しない
        - 新たな関数を、既存のデータ構造に影響を与えずに追加できるが、
        新たなデータ構造を追加するには、既存の全ての関数を変えなければならない
    - オブジェクト
        - オブジェクトは、裏にあるデータを隠して抽象化し、データの操作する機能を公開する
        - 新たなクラスを、既存の関数を変えることなく追加できるが、
        新たな関数を追加するには、全てのクラスを変えなければならない
- デメテルの法則
    - 電車の衝突
    - 混血児
        - private変数を実質publicのように公開されたデータ構造と、重要な処理を行う関数を持った混血児クラスを作ってはいけない
- データ転送オブジェクト
    - アクティブレコード


### 第7章 エラー処理

- エラー処理
    - エラー処理は重要だが、本来のロジックが不明瞭にならないようにする必要がある
- リターンコードではなく、例外を使用する
    - エラー処理は、例外を投げてtry/catch文で処理する方が、本来のロジックと2つに関心事を分けることができ、明瞭なコードになる
- 最初にtry-catch-finally文を書く
    - tryブロックはトランザクションのように捉えることができ、最初にtry-catch-finally文を書くと、スコープを意識したコードが書ける
- 非チェック例外を使用する
- 例外で状況を伝える
    - 例外は、エラー場所や原因を判断できる十分な情報を伝える必要がある
- 呼び出し元が必要とする例外クラスを定義する
    - 多くの種類の例外を設定していて、エラー処理の内容が例外の種類によって変わらないのであれば、ラップして共通の例外を投げるようにする
    - こうすることによって以下のメリットがある
        - アプリケーションを特定のベンダのAPIの設計に依存させなくて済む
        - 別のライブラリへの乗り換えが容易になる
        - テストを行う際に、サードパーティライブラリのモック作成が容易になる
    - 例外の情報によってエラーの判別は可能なので、多くの場合、特定の領域のコードでは、1つの例外クラスを使用することが適している
    - 別の例外はキャッチしたくないという場合に限って別のクラスを使用するようにする
- 正常ケースのフローを定義する
    - 例外処理によって、本来の処理が分断されるのは良くない
    - スペシャルケース（null object）パターンを利用して、例外処理を必要としない設計にする
- nullを返さない
    - nullを返したい時は、例外を投げるかスペシャルケース（null object）パターンを検討して、nullチェック文を無くす
    - サードパーティのAPIに関しても、nullを返すのであればそのメソッドをラップして上記の方法を検討する
- nullを渡さない
    - 多くのプログラミング言語ではnullが渡され場合、上手く対処する方法がない（例外を投げるよりアサーションを使うことで文章化できるが、根本的な問題を解決するわけではない）
    - nullを渡すことを禁止とし、nullが入ってきた場合は何らかの間違いとする
- 結論
    - クリーンコードは読みやすいだけではなく、堅牢でなくてはならない

### 第8章 境界

- サードパーティーのコードを使用する
    - インターフェイス境界をシステム内で持ち回るべきではない
    - クラスの中だけ、あるいは、強い関連をもたクラスに止める
- 境界の調査と学習
    - サードパーティーのコードの使い方を学ぶときに、そのコードのテストを書いて学習する「学習テスト」という方法がある
- log4jを学習する
- 学習テストは、タダ以上のものである
- まだ存在しないコードを使用する
    - APIの設計がまだされていない場合、Adapterパターンを使う
    - AdapterパターンはAPIとのやりとりをカプセル化し、変更箇所を1箇所に局所化できる
- きれいな境界
    - 自分達が制御できないもの（サードパーティーコード）ではなく、制御できるものに対して依存するようにする
    - サードパーティーとの境界を管理するためん、コードの中に非常に小さな領域を設け、そこからサードパーティーのコードの問い合わせを行うようにする
